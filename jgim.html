<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<script language="javascript" src="js/pattern.js"></script>
<script language="javascript" src="js/stroke.js"></script>
<script language="javascript" src="js/partials.js"></script>
<script language="javascript" src="js/keymap.js"></script>
<script language="javascript" src="js/charset.js"></script>
<script language="javascript" src="js/partial_nv.js"></script>
<script type="text/javascript">

function isUndefined(v)
{
	if (v == undefined)
		return true;
	return false;
}

function pattnNotBelongsTo(pattn, pattns)
{
	for (var i in pattns) {
		var p = pattns[i];
		if (p == pattn)
			return false;
	}
	return true;
}

function pattnBelongsTo(pattn, pattns)
{
	return !pattnNotBelongsTo(pattn, pattns);
}

function isPartial(later)
{
	return later > 1000;
}

function isCodeACount(c)
{
	return c >= '1' && c <= '5';
}

function StrokeIndex()
{
	this.laterIndex = 0;
	this.partIndex = 0;
}

StrokeIndex.prototype.set = function (l_idx, p_idx)
{
	this.laterIndex = l_idx;
	this.partIndex = p_idx;
}

function isStrokeIndexEqual(si1, si2)
{
	if (si1 == null || si2 == null)
		return false;
	return si1.laterIndex == si2.laterIndex
		&& si1.partIndex == si2.partIndex;
}

function getNextStrokeIndex(later, now)
{
	var nxt = new StrokeIndex();
	var ltr = later[now.laterIndex];
	if (isPartial(ltr)) {
		nxt.laterIndex = now.laterIndex;
		nxt.partIndex = now.partIndex + 1;
		var part = getPartialStrokesByIndex(ltr);
		if (isUndefined(part[nxt.partIndex])) {
			nxt.laterIndex = now.laterIndex + 1;
			nxt.partIndex = 0;
		}
	} else {
		nxt.laterIndex = now.laterIndex + 1;
		nxt.partIndex = 0;
	}
	if (isUndefined(later[nxt.laterIndex])) {
		return null;
	}
	return nxt;
}

function add_repeater(repeaters, later_index, partial_index)
{
	var pfirst = new StrokeIndex();
	pfirst.set(later_index, partial_index);

	repeaters[repeaters.length].pos_start = pfirst;
	repeaters[repeaters.length].pos_now = pfirst;
}

function getRepeaterIterateStatus(later, repeaters, count)
{
	var c = 0;
	if (repeaters.length < count) {
		return -1;
	}
	for (var i in repeaters) {
		if (i == 0) {
			continue;
		}
		var rprv = repeaters[i-1];
		var rnow = repeaters[i];
		if (isStrokeIndexEqual(getNextStrokeIndex(later, rprv.pos_now), rnow.pos_start)) {
			c++;
		}
	}
	if ((c+1) >= count) {
		return 1;
	} else {
		return 0;
	}
}

function getPartialStrokesByIndex(idx)
{
	return partial_strokes[partial_nv[idx]];
}

function getStrokeByIndex(later, idx)
{
	var ltr = later[idx.laterIndex];

	if (isUndefined(ltr)) {
		return null;
	}

	if (isPartial(ltr)) {
		var part = getPartialStrokesByIndex(ltr);
		if (isUndefined(part) || isUndefined(part[idx.partIndex])) {
			return null;
		} else {
			return part[idx.partIndex];
		}
	} else {
		if (idx.partIndex != 0) {
			return null;
		} else {
			return ltr;
		}
	}
}

function isStrokeEqual(s1, s2)
{
	if (s1 == null || s2 == null)
		return false;
	return s1 == s2;
}

function checkForNextStroke(later, repeaters)
{
	var rfirst, rnxt;
	var si_first, si_nxt;
	var s_first, s_nxt;

	rfirst = repeaters[0];
	si_first = getNextStrokeIndex(rfirst.pos_now);
	s_first = getStrokeByIndex(later, si_first);
	for (var i = 1; i < repeaters.length;) {
		rnxt = repeaters[i];
		si_nxt = getNextStrokeIndex(rnxt.pos_now);
		s_nxt = getStrokeByIndex(later, si_nxt);
		if (isStrokeEqual(s_first, s_nxt)) {
			rnxt.pos_now = si_nxt;
			i++;
		} else {
			repeaters.splice(i, 1);
		}
	}
	rfirst.pos_now = si_first;
}

function findStrokeInPartial(part, from, strokes)
{
	var idx = (from < 0 ? 0 : from);
	var len = part.length;
	for (; idx < len; idx++) {
		if (pattnBelongsTo(part[idx], strokes)) {
			return idx;
		}
	}
	return -1;
}

function findScodeInLater(later, si_idx, strokes)
{
	var l_idx = si_idx.laterIndex;
	var p_idx = si_idx.partIndex;
	var later_len = later.length;

	/* search from last l_idx+1 */
	for (; l_idx < later_len; l_idx++) {
		var found = false;
		var ltr = later[l_idx];
		if (isPartial(ltr)) {
			var part = getPartialStrokesByIndex(ltr);
			p_idx = findStrokeInPartial(part, p_idx, strokes);
			if (p_idx != -1) {
				found = true;
			} else {
				p_idx = 0;
			}
		} else {
			p_idx = 0;
			if (pattnBelongsTo(ltr, strokes)) {
				found = true;
			}
		}

		if (found) {
			si_idx.set(l_idx, p_idx);
			return true;
		}
	}
	return false;
}

function getRepeaters(later, si_idx, strokes)
{
	var l_idx = si_idx.laterIndex;
	var p_idx = si_idx.partIndex;
	var repeaters = new Array();

	for (; l_idx < later_len; l_idx++) {
		var ltr = later[l_idx];
		if (isPartial(ltr)) {
			var part = getPartialStrokesByIndex(ltr);
			var part_len = part.length;
			for (; p_idx < part_len; p_idx++) {
				if (pattnBelongsTo(part[p_idx], strokes)) {
					add_repeater(repeaters, l_idx, p_idx);
				}
			}
			p_idx = 0;
		} else {
			if (pattnBelongsTo(ltr, strokes)) {
				/* p_idx equals to 0; */
				add_repeater(repeaters, l_idx, p_idx);
			}
		}
	}
	return repeaters;
}

function checkForCountScode(later, repeaters, count)
{
	var stat = 0;
	while (repeaters.length >= count) {
		checkForNextStroke(later, repeaters);
		stat = getRepeaterIterateStatus(later, repeaters, count);
		if (stat == 1) {
			return true;
		} else if (stat == -1) {
			return false;
		} else {
			continue;
		}
	}
}

function findCountScodeInLater(later, si_idx, strokes, count)
{
	var later_len = later.length;

	/* 1. search for all cnow */
	var repeaters = getRepeaters(later, si_idx, strokes);;

	/* 2. check for later strokes */
	var isOk = checkForCountScode(later, repeaters, count);

	/* 3. set back l_idx & p_idx */
	if (isOk) {
		/* not really the last, there maybe more than
		 	`count' number of same partials */
		var si_last = repeaters[count-1].pos_now;
		si_idx = si_last;
		return true;
	} else {
		return false;
	}
}

function laterInMapping(later, scode)
{
	var cnow = 0;
	var cprv = 0;
	var si_idx = new StrokeIndex();
	var scode_len = scode.length;

	for (var s_idx = 0; s_idx < scode_len; s_idx++) {
		cprv = cnow;
		cnow = scode.charAt(s_idx).toUpperCase();
		if (isCodeACount(cnow)) {
			continue;
		} else {
			/* strokes is asured to be exist */
			var strokes = stroke_maps[cnow];
			var found = false;
			if (isCodeACount(cprv)) {
				/* search for count cnow in later */
				/* it's been asured that
	   				cnow is not a number */
				found = findCountScodeInLater(later, si_idx, strokes, cprv); 
			} else {
				/* search for cnow in later */
				found = findScodeInLater(later, si_idx, strokes);
			}
			if (!found) {
				return false;
			}
		}
	}
	return true;
}

function scodeNotInLaterMap(scode)
{
	var cnow = 0;
	var cprv = 0;
	for (var i = scode.length-1; i >= 0; i--) {
		cnow = cprv;
		cnow = scode.charAt(i).toUpperCase();
		if (isCodeACount(cnow)) {
			if (isCodeACount(cprv)) {
				return true;
			} else {
				continue;
			}
		}
		if (isUndefined(stroke_maps[cnow])) {
			return true;
		}
	}
	return false;
}

function scode_change()
{
	var input = document.getElementById("input");
	var candi = document.getElementById("candidates");
	var scode = input.value;
	var patterns = pattern_maps[scode.charAt(0).toUpperCase()];
	if (isUndefined(patterns)) {
		candi.value = "No first pattern.";
		return;
	}
	if (scodeNotInLaterMap(scode.substring(1))) {
		candi.value = "No later patial.";
		return;
	}

	var candidates = new Array();
	for (var i in Characters) {
		var c = Characters[i];
		if (pattnNotBelongsTo(c.first, patterns)) {
			continue;
		}
		if (scode.length == 1) {
			candidates[candidates.length] = c;
		} else if (laterInMapping(c.later, scode.substring(1))) {
			candidates[candidates.length] = c;
		}
	}
	var candi_chars = "";
	for (var i in candidates) {
		var c = candidates[i];
		candi_chars += c.char + " ";
	}
	candi.value = candi_chars;
}

</script>

</head>

<body>
	Input: <input type="text" id='input' onkeyup="scode_change()"><br /><br />
	Candidates: <br />
	<textarea  id="candidates" style="width: 250px; height: 230px;">
	</textarea>
</body>

</html>
